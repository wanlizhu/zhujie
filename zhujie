#!/bin/bash

# System
export __GL_SYNC_TO_VBLANK=0
export PATH="$HOME:$HOME/bin:$HOME/.local/bin:$PATH"

# Add zhujie to PATH
which zhujie > /dev/null || (
    export PATH="$(dirname $0):$PATH"
)

# NVIDIA tools
export PATH="$HOME/NVIDIA_TOOLS:$PATH"
if [[ -d $HOME/NVIDIA_TOOLS ]]; then
    for SUBDIR in $(ls -F $HOME/NVIDIA_TOOLS | grep / | awk'{print substr($0, 1, length($0)-1)}'); do
        case $SUBDIR in
            PIC-V|PIC-G|flamegraph) 
                export PATH="$HOME/NVIDIA_TOOLS/$SUBDIR:$PATH" 
            ;;
            P4V)
                export PATH="$HOME/NVIDIA_TOOLS/P4V/bin:$PATH"
            ;;
            Nsight_Graphics)
                export PATH="$HOME/NVIDIA_TOOLS/Nsight_Graphics/host/linux-desktop-nomad-x64:$PATH"
            ;;
        esac
    done 
fi

# Perforce
case $(hostname) in
    nvidia-master) 
        export P4USER=wanliz
        export P4PASSWD=""
        export P4ROOT=$HOME/NVIDIA_SRC_P4SW
        export P4CLIENT=nvidia-src-zhujie 
        export P4PORT=p4proxy-zj.nvidia.com:2006
        export P4IGNORE=$HOME/NVIDIA_P4IGNORE
        export PATH="$P4ROOT/sw/misc/linux:$P4ROOT/sw/automation/dvs/dvsbuild:$P4ROOT/sw/pvt/dleone/bin:$PATH"
    ;;
    nvidia-wingman) 
        export P4USER=wanliz
        export P4PASSWD=""
        export P4ROOT=$HOME/NVIDIA_SRC_P4SW
        export P4CLIENT=nvidia-src-zhujie 
        export P4PORT=p4proxy-zj.nvidia.com:2006
        export P4IGNORE=$HOME/NVIDIA_P4IGNORE 
        export PATH="$P4ROOT/sw/misc/linux:$P4ROOT/sw/automation/dvs/dvsbuild:$P4ROOT/sw/pvt/dleone/bin:$PATH"
    ;;
esac

function on-user-cancel() {
    echo ""
    popd > /dev/null
    exit 0
}

function combine-file-lines() {
    INFILE=$1
    tr -d '\r' < "$INFILE" > /tmp/combine-lines
    sed ':a;N;$!ba;s/\n/, /g' /tmp/combine-lines | sed 's/\n$//g'
}

function check-display() {
    INVALID=0
    if [[ -z $DISPLAY ]]; then
        echo "Error: DISPLAY is not set" > /dev/stderr
        INVALID=1
    fi

    glxinfo 1> /dev/null 2> /dev/null || (
        echo "Error: Unable to open display $DISPLAY" > /dev/stderr
        INVALID=1
    )

    if [[ $INVALID == 1 ]]; then
        read -p "Open display: (empty for :0) " RSVP
        case $RSVP in
            "") export DISPLAY=:0 ;;
             *) export DISPLAY=$RSVP ;;
        esac
    fi

    glxinfo 1> /dev/null 2> /dev/null || (
        echo "Error: Unable to open display $DISPLAY" > /dev/stderr
        exit 1
    )
}

function has-nvidia-gpu() { 
    [[ -n $(lspci | grep NVIDIA) ]] && echo 1 || echo 0
}

function cpu() {
    # CPU Model Name
    echo -ne "CPU Model Name: " 
    lscpu | grep "Model name:" | awk -F "name:" '{print $2}' | awk '{$1=$1; print}'
    
    # lscpu --all --extended 
}

function gpu() {
    # NVIDIA GPU(s)
    nvidia-smi-static
}

function nvidia-smi-static() {
    which nvidia-smi > /dev/null || echo "Info: can't find nvidia-smi in PATH"
    
    nvidia-smi --query | grep "Driver Version" | awk -F ":" '{print "NVIDIA Driver Version:" $2}'
    
    # NVIDIA RM Version 
    if [[ -f /proc/driver/nvidia/version ]]; then 
        cat /proc/driver/nvidia/version | head -n 1
    fi
    
    GPU_COUNT=$(nvidia-smi -L | wc -l)
    echo "Attached NVIDIA GPUs:"
    
    for INDEX in `seq 0 $(($GPU_COUNT-1))`; do
        if [[ $INDEX > 0 ]]; then
            echo ""
        fi
        
        nvidia-smi -L | awk -F '\(UUID:' '{print $1}' | awk  "NR==$(($INDEX+1)){ print; exit; }"
        nvidia-smi --query --id=$INDEX > /tmp/nvidia-gpu-$INDEX.info
        python3 -c "
import sys
with open(\"/tmp/nvidia-gpu-$INDEX.info\", 'r') as file:
    lines = [ line.strip() for line in file.readlines() ]
    NR = -1
    for line in lines:
        NR += 1
        words = line.split()
        if line.startswith('Display Mode'):
            print('Monitor Attached: {}'.format('YES' if words[3] == 'Enabled' else 'NO'))
            continue
        if NR >= 1 and lines[NR - 1] == 'FB Memory Usage':
            print('Total VRAM: {} MB'.format(words[2]))
            continue
        if NR >= 1 and lines[NR - 1] == 'BAR1 Memory Usage':
            print('Total Bar1 Memory: {} MB'.format(words[2]))
            continue
        if NR >= 6 and lines[NR - 6] == 'GPU Power Readings':
            print('Max Power Limit: {} W'.format(words[4]))
            continue
        if NR >= 1 and lines[NR - 1] == 'Max Clocks':
            print('Max Graphics Clock: {} MHz'.format(words[2]))
            continue        
" > /tmp/nvidia-gpu-$INDEX.info.static
        cat /tmp/nvidia-gpu-$INDEX.info.static 
    done
}

function cpu-usage() {
    echo 0.5
}

function nvidia-smi-dynamic() {
    which nvidia-smi > /dev/null || echo "Info: can't find nvidia-smi in PATH"
    
    GPU_COUNT=$(nvidia-smi -L | wc -l)
    echo "Attached NVIDIA GPUs:"
    
    for INDEX in `seq 0 $(($GPU_COUNT-1))`; do
        if [[ $INDEX > 0 ]]; then
            echo ""
        fi

        nvidia-smi -L | awk -F '\(UUID:' '{print $1}' | awk  "NR==$(($INDEX+1)){ print; exit; }"
        nvidia-smi --query --id=$INDEX > /tmp/nvidia-gpu-$INDEX.info
        python3 -c "
import sys
with open(\"/tmp/nvidia-gpu-$INDEX.info\", 'r') as file:
    lines = [ line.strip() for line in file.readlines() ]
    NR=-1
    for line in lines:
        NR += 1
        words = line.split()
        if NR >= 1 and lines[NR - 1] == 'Utilization':
            print('GPU Utilization: {} %'.format(words[2]))
            break
" > /tmp/nvidia-gpu-$INDEX.info.dynamic
        
        cat /tmp/nvidia-gpu-$INDEX.info.dynamic
    done
}

function nvidia-smi-perf() {
    WAIT=$1
    DURATION=$2
    INTERVAL=1
    CSV_NAME=/tmp/nvidia-smi-perf.csv
    
    if [[ -z $WAIT ]]; then
        WAIT=0
    fi
    
    while [[ $WAIT > 0 ]]; do
        sleep 1
        WAIT=$(($WAIT - 1))
    done
    
    if [[ -z $DURATION ]]; then
        DURATION=20
    fi
    
    if [[ -f $CSV_NAME ]]; then
        rm -rf $CSV_NAME
    fi
    
    echo "GPU Usage,CPU Usage" > $CSV_NAME
    
    for i in `seq 0 $INTERVAL $DURATION`; do
        nvidia-smi-dynamic > /dev/null
        python3 -c "
import sys
GPU_Usage = 0.0
with open(\"/tmp/nvidia-gpu-0.info.dynamic\", 'r') as file:
    for line in [ line.strip() for line in file.readlines() ]:
        words = line.split()
        if line.startswith('GPU Utilization:'):
            GPU_Usage = float(words[2])
            break
CPU_Usage = 0.0
with open(\"$CSV_NAME\", 'a') as file:
    file.write('{},{}\n'.format(GPU_Usage, CPU_Usage))
"
        sleep $INTERVAL
    done
}

function display() {
    # Monitor
    which xdpyinfo > /dev/null && (
        TMP=$(xdpyinfo 2> /dev/null | grep dimensions)
        echo "Monitor:" ${TMP#  dimensions:    }
    )
    
    if [[ -n `ls -A /tmp/.X11-unix` ]]; then
        echo -ne ".X11-unix: [" && (cd /tmp/.X11-unix && for x in $(ls); do echo -ne ":${x#X} "; done; echo "]")
    else
        echo ".X11-unix: [NULL]"
    fi
    
    echo "DISPLAY: $([[ -n $DISPLAY ]] && echo $DISPLAY || '[NULL]')"
}

function info() {
    if [[ $(uname) == Darwin ]]; then
        return
    fi
    
    echo "Kernel: $(uname -r)"
    cpu && echo 
    gpu && echo 
    display && echo 
}

function nvmake() {
    MODULE=$1
    ARCH=$2
    BUILD_TYPE=$3
    NVBRANCH=sw/dev/gpu_drv/dev_a

    if [[ -z $P4ROOT ]]; then
        echo "Error: P4ROOT is not configured" > /dev/stderr
        exit 1
    fi

    if [[ -z $NVBRANCH ]]; then
        echo "Error: NVBRANCH is not configured" > /dev/stderr
        exit 1
    fi

    if [[ $(stat -c '%U' $P4ROOT/sw/misc/linux/unix-build) != root ]]; then
        UNIX_BUILD_ARGS="--unshare-namespaces"
    fi

    case $MODULE in
         dev_a) MODULE="drivers dist" ;;
        opengl) exit 1 ;; #TODO
           ppp) MODULE="post-process-packages dist" ;;
         sweep)
            pushd $P4ROOT/$NVBRANCH > /dev/null
            $P4ROOT/sw/misc/linux/unix-build $UNIX_BUILD_ARGS \
                --tools "$P4ROOT/sw/tools" \
                --devrel "$P4ROOT/sw/devrel/SDK/inc/GL" \
                nvmake sweep
            popd > /dev/null 
            return 0
        ;;
        *)
            echo "Error: NVIDIA module '$MODULE' is not supported" > /dev/stderr
            exit 1
        ;;
    esac

    ERROR=0
    SECONDS=0

    echo "NVMake: linux $MODULE $ARCH $BUILD_TYPE"
    mkdir -p $HOME/NVIDIA_OUT/Linux-$MODULE-$ARCH-$BUILD_TYPE
    pushd $P4ROOT/$NVBRANCH > /dev/null
    $P4ROOT/sw/misc/linux/unix-build $UNIX_BUILD_ARGS \
        --tools "$P4ROOT/sw/tools" \
        --devrel "$P4ROOT/sw/devrel/SDK/inc/GL" \
        nvmake \
        NV_COLOR_OUTPUT=1 \
        NV_COMPRESS_THREADS=16 \
        NV_FAST_PACKAGE_COMPRESSION=1 \
        NV_EXCLUDE_BUILD_MODULES="" \
        NV_KEEP_UNSTRIPPED_BINARIES=0 \
        NV_GUARDWORD=0 \
        -j16 \
        linux \
        $ARCH \
        $BUILD_TYPE \
        $MODULE \
        1> $HOME/NVIDIA_OUT/Linux-$MODULE-$ARCH-$BUILD_TYPE/nvmake.log \
        2> $HOME/NVIDIA_OUT/Linux-$MODULE-$ARCH-$BUILD_TYPE/nvmake.error && (
        echo "NVMake: $(expr $SECONDS / 60) mins"
        popd > /dev/null 
    ) || (
        grep -E -i -w "fatal|error|errors|critical|failed|: \*\*\*" $HOME/NVIDIA_OUT/Linux-$MODULE-$ARCH-$BUILD_TYPE/nvmake.error;
        popd > /dev/null 
        exit 1
    )
}

function build() {
    if [[ -z $1 ]]; then
        echo "Usage: build <dev_a|opengl|sweep|ppp> [ARCHS...] [TYPES...]" > /dev/stderr
        exit 1
    fi

    ARCHS=""
    BUILD_TYPES=""
    MODULES=""

    while [[ -n $1 ]]; do
        case $1 in
                        amd64|x86) ARCHS="$ARCHS $1" ;;
            debug|release|develop) BUILD_TYPES="$BUILD_TYPES $1" ;;
                     dev_a|opengl) MODULES="$MODULES $1" ;;
                            sweep) nvmake sweep * *; return ;;
                              ppp) nvmake ppp * *; return ;;   
            *)
                echo "Error: unknown argument '$1'" > /dev/stderr
                build
                exit 1
            ;;
        esac
        shift
    done

    if [[ -z $ARCHS ]]; then
        ARCHS=amd64
    fi

    if [[ -z $BUILD_TYPES ]]; then
        BUILD_TYPES=release
    fi

    for MODULE in $MODULES; do
        for ARCH in $ARCHS; do
            for BUILD_TYPE in $BUILD_TYPES; do
                nvmake "$MODULE" "$ARCH" "$BUILD_TYPE"
            done
        done
    done    
}

function install() {
    if [[ -z $1 ]]; then
        echo "Usage: install [OPTIONS]" > /dev/stderr
        echo "    e.g. install <INSTALLER_PATH>" > /dev/stderr
        echo "    e.g. install <MODULE> <ARCH> <BUILD_TYPE>" > /dev/stderr
        echo "    e.g. install <-r|--revert> <ARCH>" > /dev/stderr
        echo "    e.g. install mesa [version]" > /dev/stderr
        exit 1
    fi

    case $1 in
        opengl)
            MODULE=$1
            shift
            update-nvidia-libs $MODULE "$@"
        ;;
        -r|--revert)
            shift
            revert-nvidia-libs "$@"
        ;;
        mesa)
            exit 1 #TODO
            glxinfo | grep "OpenGL renderer"
        ;;
        mainline)
            sudo add-apt-repository ppa:cappelikan/ppa
            sudo apt update
            sudo apt install mainline
            which mainline    
        ;;
        gtlfs)
            wget https://gtlfs.nvidia.com/client/linux -O ~/gtlfs
            chmod +x ~/gtlfs
        ;;
        terminus)
            wget https://sourceforge.net/projects/terminus-font/files/terminus-font-4.49/terminus-font-4.49.1.tar.gz/download -O /tmp/terminus-font-4.49.1.tar.gz
            cd /tmp
            tar -xvf terminus-font-4.49.1.tar.gz
            cd terminus-font-4.49.1
            ./configure
            make -j8
            sudo make install fontdir
        ;;
        *)
            if [[ -f $1 || -L $1 ]]; then
                run-nvidia-installer "$1"
            else
                echo "Error: '$1' doesn't exist" > /dev/stderr
                exit 1
            fi
        ;;
    esac
}

function remove() {
    if [[ -z $1 ]]; then
        echo "Usage: remove [OPTIONS]" > /dev/stderr
        echo "    e.g. remove mesa" > /dev/stderr
        exit 1
    fi

    case $1 in
        mesa)
            exit 1 #TODO
        ;;
        mainline)
            sudo add-apt-repository --remove ppa:cappelikan/ppa
            sudo apt remove mainline
        ;;
        gtlfs)
            rm -rf ~/gtlfs
        ;;
        *)
            echo "Error: can't remove '$1'" > /dev/stderr
            exit 1
        ;;
    esac
}

function run-nvidia-installer() {
    INSTALLER=$1
    if [[ -z $INSTALLER ]]; then
        echo "Usage: run-nvidia-installer <INSTALLER_PATH>" > /dev/stderr
        exit 1
    fi

    if [[ ! -f $INSTALLER ]]; then
        echo "Error: NVIDIA installer '$INSTALLER' doesn't exist" > /dev/stderr
        exit 1
    fi

    sudo chmod +x "$INSTALLER"

    who am i > /dev/null && (
        sudo systemctl isolate multi-user
        sudo "$INSTALLER" -sb
        sudo systemctl isolate graphical
    ) || (
    	echo "Error: can't run NVIDIA installer locally" > /dev/stderr
        exit 1
    )	
}

function revert-nvidia-libs() {
    if [[ -z $1 ]]; then
        echo "Usage: revert-nvidia-libs <ARCH>" > /dev/stderr
        exit 1
    fi

    ARCH=$1 && shift
    ARCHNAME=$([[ $ARCH == amd64 ]] && echo x86_64 || echo i386)
    FOLDER=/usr/lib/$ARCHNAME-linux-gnu

    for FILE in `ls $FOLDER/*.backup`; do
        sudo mv -f "$FILE" "${FILE%.*}"
        echo "Reverted: ${FILE%.*}"
    done
}

function update-nvidia-libs() {
    if [[  -z $1 || -z $2 || -z $3 ]]; then
        echo "Usage: update-nvidia-libs <MODULE> <ARCH> <BUILD_TYPE>" > /dev/stderr
        exit 1
    fi

    MODULE=$1 && shift
    ARCH=$1 && shift
    BUILD_TYPE=$1 && shift 
    FOLDER="Linux_"$ARCH"_$BUILD_TYPE"

    if [[ $(nvidia-source-version) != $(nvidia-version-installed $ARCH) ]]; then  
        echo "Error: NVIDIA modules are version locked can't overwrite *.so.$(nvidia-version-installed $ARCH) with *.so.$(nvidia-source-version)" > /dev/stderr
        exit 1
    fi

    echo "Info: update NVIDIA module [$MODULE $ARCH $BUILD_TYPE]"
    case $MODULE in
        opengl)
            FOLDER="Linux_"$ARCH"_$BUILD_TYPE"
            OUTDIR=$P4ROOT/$NVBRANCH/drivers/OpenGL/_out/$FOLDER
            BASENAMES=libnvidia-glcore.so

            for BASENAME in $BASENAMES; do
                VERSION=$(nvidia-source-version)
                ARCHNAME=$([[ $ARCH == amd64 ]] && echo x86_64 || echo i386)
                TARGETNAME=/usr/lib/$ARCHNAME-linux-gnu/$BASENAME.$VERSION

                if [[ -f $TARGETNAME || -L $TARGETNAME ]]; then
                    if [[ ! -f $TARGETNAME.backup ]]; then
                        sudo mv $TARGETNAME $TARGETNAME.backup
                    fi
                    sudo cp -f $OUTDIR/$BASENAME $TARGETNAME
                else
                    echo "Error: '$TARGETNAME' is missing" > /dev/stderr
                    exit 1
                fi

                echo "Updated: $TARGETNAME"
            done
        ;;
        *)
            echo "Error: NVIDIA module '$MODULE' is not supported" > /dev/stderr
            exit 1
        ;;
    esac 
}

function nvidia-source-version() {
    echo `grep '^#define NV_VERSION_STRING' $P4ROOT/$NVBRANCH/drivers/common/inc/nvUnixVersion.h  | awk '{print $3}' | sed 's/"//g'`
}

function nvidia-version-installed() {
    if [[ -z $1 ]]; then
        echo "Usage: nvidia-version-installed <ARCH>" > /dev/stderr
        exit 1
    fi  

    ARCH=$1
    ARCHNAME=$([[ $ARCH == amd64 ]] && echo x86_64 || echo i386)
    SOFILE=$(ls /usr/lib/$ARCHNAME-linux-gnu/libnvidia-glcore.so* | head -n 1)
    POS=$([[ $ARCH == amd64 ]] && echo 46 || echo 44)
    LEN=$(( ${#SOFILE} - POS ))
    VERSION=${SOFILE:$POS:$LEN}

    if [[ -f /usr/lib/$ARCHNAME-linux-gnu/libnvidia-glvkspirv.so.$VERSION ]]; then
        echo $VERSION
    else
        echo "Error: can't parse NVIDIA version installed" > /dev/stderr
        exit 1
    fi
}

function ddnet() {
    # 2560x1440
    # Fullscreen
    # Vulkan
    # Default
    # RaiNyMore2 -- GPU-intensive 

    check-display

    (echo 7; echo 2; echo 1; echo 1; echo 2; echo n) | phoronix-test-suite benchmark pts/ddnet
}

function click-talos-message-window() {
    which xdotool > /dev/null || sudo apt install -y xdotool
    sleep 3
    
    VALID=1
    while [[ $VALID == 1 ]]; do
        WINDOW_ID=$(xdotool getactivewindow)
        WINDOW_NAME=$(xdotool getwindowname $WINDOW_ID)
        if [[ $WINDOW_NAME == Message ]]; then
            POSITION=$(xdotool getwindowgeometry $WINDOW_ID | grep Position: | awk '{print $2}')
            EXTENT=$(xdotool getwindowgeometry $WINDOW_ID | grep Geometry: | awk '{print $2}')
            X=${POSITION%,*}; Y=${POSITION#*,}
            W=${EXTENT%x*};   H=${EXTENT#*x}
            xdotool mousemove $((X+W-50)) $((Y+H-70))
            xdotool click 1
        else #elif [[ $WINDOW_NAME == "Talos - Linux - 64bit" ]]; then
            sleep 10
        fi
        
        if [[ -z $(pidof Talos) ]]; then
            VALID=0
        fi
    done
}

function kill-talos-later() {
    sleep 30

    STOP=0
    SECONDS=0
    while [[ $STOP == 0 ]]; do
        if [[ ! -f $HOME/zhujie-talos.log ]]; then
            STOP=1
            continue
        fi

        LINE=$(cat $HOME/zhujie-talos.error | grep "corrupted size vs. prev_size")
        if [[ -n $LINE ]]; then
            pkill -9 Talos 
            STOP=1
            sleep 2
        else
            if [[ -z $(pidof Talos) ]]; then
                STOP=1
            fi
            sleep 2
        fi
    done
}

function talos() {
    # Vulkan
    # 2560x1440

    check-display
    
    ROUNDS=1
    VERBOSE=0
    
    while [[ -n $1 ]]; do
        case $1 in
            [0-9]*) ROUNDS=$1 ;;
            -v|--verbose) VERBOSE=1 ;;
        esac
        shift
    done

    # Launch steam if it's not currently running
    pgrep -x steam >/dev/null || (
        steam &
        sleep 20
    )

    if [[ ! -f "$HOME/.steam/steam/steamapps/common/The Talos Principle/Bin/x64/Talos" ]]; then
        echo "Error: install 'Talos Principle' in steam's window and try again" > /dev/stderr
        exit 1
    fi

    click-talos-message-window &
    kill-talos-later &

    if [[ $ROUNDS > 1  && -f /tmp/zhujie-talos-$ROUNDS-rounds.fps ]]; then
        rm -rf /tmp/zhujie-talos-$ROUNDS-rounds.fps
    fi
    
    pushd "$HOME/.steam/steam/steamapps/common/The Talos Principle/Bin/x64" > /dev/null
    
    nvidia-smi-perf 25 20 &
    
    for i in `seq 1 $ROUNDS`; do
        if [[ $VERBOSE == 1 ]]; then
            ./Talos +gfx_strAPI VLK +gfx_pixResWidth 2560 +gfx_pixResHeight 1440 +exec $HOME/.phoronix-test-suite/installed-tests/pts/talos-principle-1.2.1/talos-run-test.lua
        else
            ./Talos +gfx_strAPI VLK +gfx_pixResWidth 2560 +gfx_pixResHeight 1440 +exec $HOME/.phoronix-test-suite/installed-tests/pts/talos-principle-1.2.1/talos-run-test.lua 1> $HOME/zhujie-talos.log 2> $HOME/zhujie-talos.error 
            
            cat "$HOME/zhujie-talos.log" | grep "Average:" | tail -n1 | awk '{print $3}' | tee -a /tmp/zhujie-talos-$ROUNDS-rounds.fps
        fi
    done
    
    popd > /dev/null
    
    echo ""
    
    if [[ $ROUNDS > 1 ]]; then
        echo -ne "Average FPS: "
        average /tmp/zhujie-talos-$ROUNDS-rounds.fps
    fi
    
    if [[ -f /tmp/nvidia-smi-perf.csv ]]; then
        average /tmp/nvidia-smi-perf.csv
    fi
}

function install-dvs-driver() {
    TYPE=Release
    BRANCH=""
    CL=""   

    while [[ -n $1 ]]; do
        case $1 in
              debug)  TYPE=Debug  ;;
            develop)  TYPE=Develop  ;;
              dev_a)  shift; BRANCH=dev_a; CL=$1 ;;
             public)  shift; BRANCH=public; CL=$1 ;;
            *)
                echo "Error: unknown argument '$1'" > /dev/stderr
                exit 1
            ;;
        esac
        shift
    done

    case $BRANCH in
        dev_a)
            SUFFIX=$([[ $TYPE == Debug ]] && echo -internal || echo "") 
            URL="http://linuxqa.nvidia.com/dvsbuilds/gpu_drv_dev_a_${TYPE}_Linux_AMD64_unix-build_Test_Driver/SW_$CL.0_gpu_drv_dev_a_${TYPE}_Linux_AMD64_unix-build_Test_Driver.tgz/NVIDIA-Linux-x86_64-DVS${SUFFIX}.run"
            OUT=$HOME/Downloads/NVIDIA-dev_a-$TYPE-CL$CL.run

        ;;
        public)
            PATCH=$([[ $ID == Develop ]] && echo /develop || echo "")
            URL="http://linuxqa/builds/release/display/x86_64${PATCH}/$CL/NVIDIA-Linux-x86_64-$CL.run"
            OUT=$HOME/Downloads/NVIDIA-Public-$TYPE-$CL.run
        ;;
    esac

    echo "Downloading: $OUT"   

    if [[ -f $OUT ]]; then
        echo "Reuse cache: $OUT"
        chmod 777 $OUT
    else
        TMPFILE=/tmp/$(basename $OUT)
        wget $URL -O $TMPFILE && (
            mv -f $TMPFILE $OUT
            chmod 777 $OUT
        ) || (
            echo "Error: can't download $URL" > /dev/stderr
            exit 1
        )
    fi

    if [[ -f $OUT ]]; then
        read -p "Do you want to install now? (Y/n) " RSVP
        case $RSVP in
            ""|y|Y|1)
                echo "Installing $OUT"
                install "$OUT"
            ;;
        esac
    fi
}

function drivers() {
    if [[ -z $1 ]]; then
        echo "Usage: drivers [debug] [develop] [BRANCH CL] [public RELEASE_ID]" > /dev/stderr
        echo "    e.g. drivers dev_a CL" > /dev/stderr
        echo "    e.g. drivers dev_a CL debug" > /dev/stderr
        echo "    e.g. drivers public RELEASE_ID" > /dev/stderr
        echo "    e.g. drivers public RELEASE_ID develop" > /dev/stderr
        exit 1
    fi

    IS_PUBLIC=0
    for VAR in $@; do
        case $VAR in
            public) IS_PUBLIC=1 ;;
        esac
    done

    if [[ ! -f /mnt/linuxqa/nvt.sh || $IS_PUBLIC != 1 ]]; then
        install-dvs-driver "$@"
    else
        /mnt/linuxqa/nvt.sh drivers "$@"
    fi
}

function flamegraph() {    
    which perf || (
        echo "Error: can't find perf in PATH" > /dev/stderr
        exit 1
    )

    NAME=Perf-NoName
    SVG_FILE=$HOME/$NAME.svg
    PERF_DATA=$HOME/$NAME.data
    PERF_RECORD_SYSTEM_WIDE=1
    PERF_RECORD_PID=" -a "
    PERF_RECORD_SECONDS=10
    PERF_RECORD_ARGS=" -F 100 -g --call-graph dwarf "

    while [[ -n $1 ]]; do
        case $1 in
            -n|--name)
                shift
                NAME=$1
                SVG_FILE=$HOME/$NAME.svg
                PERF_DATA=$HOME/$NAME.data
            ;;
            -p|--pid)
                shift
                PERF_RECORD_SYSTEM_WIDE=0
                PERF_RECORD_PID=" --pid=$1 "
            ;;
            -s|--sleep)
                shift
                PERF_RECORD_SECONDS=$1
            ;;
            *)
	            if [[ -n $(pidof $1) ]]; then
	                NAME=$([[ $NAME == Perf-NoName ]] && echo $1 || echo $NAME)
	                SVG_FILE=$HOME/$NAME.svg
                    PERF_DATA=$HOME/$NAME.data
                    PERF_RECORD_SYSTEM_WIDE=0
                    PERF_RECORD_PID=" --pid=$(pidof $NAME) "
	            else
	                echo "Error: process $1 doesn't exist" > /dev/stderr
	                exit 1
	            fi
            ;;
        esac
        shift
    done

    perf --help 1> /dev/null 2> /dev/null || (
        sudo apt install -y linux-tools-`uname -r`
        sudo apt install -y linux-cloud-tools-`uname -r`
        sudo apt install -y linux-tools-generic
        sudo apt install -y linux-cloud-tools-generic
    )

    if [[ -f $PERF_DATA ]]; then
        rm -rf "$PERF_DATA"
    fi

    echo -ne "Info: perf record for $PERF_RECORD_SECONDS seconds\t"
    sudo perf record $PERF_RECORD_PID $PERF_RECORD_ARGS \
        --output="$PERF_DATA" \
        --sleep $PERF_RECORD_SECONDS \
        2> /tmp/$(basename $PERF_DATA).error \
        && echo "[OK]" || (
            echo "[FAILED]"
            cat /tmp/$PERF_DATA.error
            exit 1
        )
    sudo chmod 777 "$PERF_DATA"

    if [[ ! -f $PERF_DATA ]]; then
        echo "Error: '$PERF_DATA' is missing" > /dev/stderr
        exit 1
    fi
    
    BASENAME=$(basename "$PERF_DATA")
    
    echo -ne "Info: perf script\t"
    sudo perf script --input="$PERF_DATA" \
        1> "/tmp/$BASENAME.perf" \
        2> "/tmp/$BASENAME.perf.error" \
        && echo "[OK]" || (
            echo "[FAILED]"
            cat "/tmp/$BASENAME.perf.error"
            exit 1
        ) 
    
    echo -ne "Info: stackcollapse-perf.pl\t"
    sudo stackcollapse-perf.pl "/tmp/$BASENAME.perf" \
        1> "/tmp/$BASENAME.perf.folded" \
        2> "/tmp/$BASENAME.perf.folded.error" \
        && echo "[OK]" || (\
            echo "[FAILED]"
            cat "/tmp/$BASENAME.perf.folded.error"
            exit 1
        )
    
    echo -ne "Info: stackcollapse-recursive.pl\t"
    sudo stackcollapse-recursive.pl "/tmp/$BASENAME.perf.folded" \
        1> "/tmp/$BASENAME.perf.folded.recursive" \
        2> "/tmp/$BASENAME.perf.folded.recursive.error" \
        && echo "[OK]" || (\
            echo "[FAILED]"
            cat "/tmp/$BASENAME.perf.folded.recursive.error"
            exit 1
        )
    
    echo -ne "Info: flamegraph.pl\t"
    sudo flamegraph.pl "/tmp/$BASENAME.perf.folded.recursive" \
        1> "$SVG_FILE" \
        2> "/tmp/$BASENAME.perf.folded.recursive.error" \
        && echo "[OK]" || (\
            echo "[FAILED]"
            cat "/tmp/$BASENAME.perf.folded.recursive.error"
            exit 1
        )
}
    
function p4bisect() {
    which p4 || (
        echo "Error: can't find p4 in PATH" > /dev/stderr
        exit 1
    )
    
    if [[ -z $1 || -z $2 || -z $3 ]]; then
        echo "Usage: p4bisect <dev_a|opengl> <DATE_OLD> <DATE_NEW>" > /dev/stderr
        exit 1
    fi
    
    MODULE=$1
    DATE_OLD=$2
    DATE_NEW=$3
    CHANGES="$HOME/p4-changes-on-$MODULE"
    
    case $MODULE in
         dev_a) FOLDER="$P4ROOT/sw/dev/gpu_drv/dev_a" ;;
        opengl) FOLDER="$P4ROOT/sw/dev/gpu_drv/dev_a/drivers/OpenGL" ;;
        *)
            echo "Error: NVIDIA module '$1' is not supported" > /dev/stderr
            exit 1
        ;;
    esac 
    
    p4 changes -s submitted $FOLDER/...@$DATE_OLD,@$DATE_NEW > $CHANGES
    LINE_COUNT=$(wc -l < $CHANGES)
        
    while [[ $LINE_COUNT > 2 ]]; do
        LINE_NO=$(( $LINE_COUNT/2 ))
        LINE=$(sed -n "${LINE_NO}p" $CHANGES)
    
        IFS=" " read -ra SEGMENTS <<< "$LINE"
        CL="${SEGMENTS[1]}"
        DESC=$(p4 describe -s $CL | head -n 1)
    
        IFS=" " read -ra SEGMENTS <<< "$DESC"
        DATE="${SEGMENTS[5]}:${SEGMENTS[6]}"
        ANSWERED=0
    
        echo "Testing change $CL @$DATE (out of $LINE_COUNT changes):"
    
        read -p "Download from DVS build? (Y/n): " RSVP
        case $RSVP in
            y|Y|1) drivers dev_a $CL ;;
        esac
    
        read -p "Is this change new? (y/n): " RSVP 
        case $RSVP in
            y|Y|1) DATE_NEW="$DATE" ;;
            n|N|0) DATE_OLD="$DATE" ;;
        esac
    
        p4 changes -s submitted $FOLDER/...@$DATE_OLD,@$DATE_NEW > $CHANGES
        LINE_COUNT=$(wc -l < $CHANGES)
        
        echo ""
    done
}
    
function pic-v() {
    which pic-v || (
        echo "Error: can't find pic-v in PATH" > /dev/stderr
        exit 1
    )
    
    if [[ -z $1 ]]; then
        echo "Usage: pic-v [APP]" > /dev/stderr
        exit 1
    fi
    
    # Launch pic-v if it's not running
    pgrep -x pic-v >/dev/null || (
        bash -c "cd $PIC_V && ./pic-v" &
        sleep 3
    )
    
    # Launch game in current terminal 
    PIC_V_DIR=$(dirname `while pic-v | head -n 1`)
    if [[ ! -f $PIC_V_DIR ]]; then
        echo "Error: can't find pic-v's parent directory" > /dev/stderr
        exit 1
    fi
    
    cd $PIC_V_DIR
    source setup-env.sh
    
    "$@" && (
        # Launch http server if it's not running
        ps aux | grep "[p]ython3 -m http.server" || (
            bash -c "cd $PIC_V/PerfInspector/output && ./launch-py3-server.sh" &
            sleep 1
        )
    
        URL="http://localhost:8000/"
        which firefox && firefox $URL || ( 
            which chromium && chromium $URL || 
                echo "Open http://localhost:8000/ in your browser" 
        )
    )
}
    
function choose-kernel() {
    echo "Found installed kernel:"
    
    INDEX=-1
    for K in $(find /boot -name vmlinuz-* 2> /dev/null); do
        THISNAME=${K:14:$[${#K}-14]}
        MARK=$([[ $THISNAME == $(uname -r) ]] && echo "*" || echo " ")
        INDEX=$((INDEX+1))
        echo "$MARK [$INDEX]" $THISNAME
    done
    
    read -p "Choose a kernel to be default: " KNAME
    if [[ $KNAME =~ ^[0-9]+$ ]]; then
        INDEX=0
        for K in $(find /boot -name vmlinuz-* 2> /dev/null); do
            if [[ $INDEX == $KNAME ]]; then
                KNAME=${K:14:$[${#K}-14]}
                break
            else
                INDEX=$((INDEX+1))
            fi
        done
    fi
    
    INVALID=1
    for K in $(find /boot -name vmlinuz-* 2> /dev/null); do
        if [[ ${K:14:$[${#K}-14]} == $KNAME ]]; then
            INVALID=0
            break
        fi
    done
    
    if [[ $INVALID == 1 ]]; then
        echo "Error: kernel '$KNAME' is invalid" > /dev/stderr
        exit 1
    fi
    
    rm -rf /tmp/grub.tmp
    while read -r LINE; do
        if [[ $LINE == *"GRUB_DEFAULT"* ]]; then
            echo "GRUB_DEFAULT=\"Advanced options for Ubuntu>Ubuntu, with Linux $KNAME\"" >> "/tmp/grub.tmp"
        else
            echo "$LINE" >> /tmp/grub.tmp
        fi
    done < /etc/default/grub
    
    sudo cp /tmp/grub.tmp /etc/default/grub
    sudo update-grub
}
    
function fake-display() {
    if [[ $EUID != 0 ]]; then
        echo "Error: please run as root" > /dev/stderr
        exit 1
    fi
    
    RESOLUTION=$1
    if [[ $(has-nvidia-gpu) == 1 ]]; then
        if [[ -z $RESOLUTION ]]; then
            echo "Usage: fake-display [RESOLUTION]" > /dev/stderr
            read -p "Use the default resolution, 3840x2160? (Y/n): " RSVP
            case $RSVP in
                ""|y|Y|1) RESOLUTION=3840x2160 ;;
                       *) RESOLUTION=$RSVP ;;
            esac
        fi
    else
        RESOLUTION=""
        unset NVTEST_DRIVER_DIR
    fi
    
    if [[ $(has-nvidia-gpu) == 1 ]]; then
        /mnt/linuxqa/nvt.sh ${RESOLUTION}__runcmd --cmd 'sleep 100000000'
    else
        /mnt/linuxqa/nvt.sh runcmd --cmd 'sleep 100000000'
    fi
}
    
function vnc() {
    CMD=$1
    ACTUAL_DISPLAY=$2
    VNCCMD=""
    VNCPORT="5900"
    RESOLUTION=""
    
    if [[ -z $CMD ]]; then
        echo "Usage: vnc <start|stop|restart|status> [ACTUAL_DISPLAY] [RESOLUTION]" > /dev/stderr
        echo "    ACTUAL_DISPLAY: work on the actual display" > /dev/stderr
        echo "    RESOLUTION: like 3840x2160, only required when create a new virtual display" > /dev/stderr
        echo "" > /dev/stderr

        echo "/usr/bin/x0vncserver, where x0 means X session at display :0, is a simplified version of the standard /usr/bin/vncserver, x0vncserver doesn't create a virtual display, instead it just shares the actual X session at display :0 or an actual display you specified. The default port is $RFBPORT. If you want to change it, just define environment variable VNCPORT=xxx to whatever port you want the VNC server to listen to. Xvnc is started by vncserver/x0vncserver, Xvnc is actually two things together because it's an X server for local application and a VNC server for remote application." > /dev/stderr
        echo "" > /dev/stderr

        exit 1
    fi
    
    if [[ -z $ACTUAL_DISPLAY ]]; then
        VNCCMD=vncserver
        if [[ -z $RESOLUTION && $CMD == start ]]; then
            read -p "Virtual display resolution: (empty for 3840x2160) " RSVP
            case $RSVP in 
                "") RESOLUTION="-geometry 3840x2160" ;;
                 *) RESOLUTION="-geometry $RSVP" ;;
            esac
        fi
    else
        VNCCMD=x0vncserver
        RESOLUTION=""
    fi
    
    which vncserver   > /dev/null || sudo apt install -y tigervnc-standalone-server 
    which x0vncserver > /dev/null || sudo apt install -y tigervnc-scraping-server 
    
    if [[ ! -d $HOME/.vnc ]]; then
        mkdir -p $HOME/.vnc
    fi
    
    if [[ ! -f $HOME/.vnc/passwd && $CMD == start ]]; then
        echo "Creating ~/.vnc/passwd file..."
        vncpasswd || (
            echo "Error: can't generate VNC password at $HOME/.vnc/passwd" > /dev/stderr
            exit 1
        )
    fi
    
    if [[ -n $VNCPORT ]]; then
        RFBPORT="-rfbport $VNCPORT"
    fi
    
    case $CMD in
        start)
            $VNCCMD -localhost no -PasswordFile $HOME/.vnc/passwd $RFBPORT $RESOLUTION $ACTUAL_DISPLAY
        ;;
        stop)
            $VNCCMD -kill $ACTUAL_DISPLAY
        ;;
        restart)
            vnc stop  $ACTUAL_DISPLAY
            vnc start $ACTUAL_DISPLAY
        ;;
        status)
            $VNCCMD -list $ACTUAL_DISPLAY
        ;;
        *)
            vnc
            exit 1
        ;;
    esac
}
    
function apex() {
    if [[ $EUID != 0 ]]; then
        echo "Error: please run as root" > /dev/stderr
        exit 1
    fi
    
    ROUNDS=1
    VERBOSE=0
    
    while [[ -n $1 ]]; do
        case $1 in
            [0-9]*) ROUNDS=$1 ;;
            -v|--verbose) VERBOSE=1 ;;
        esac
        shift
    done
    
    if [[ $(has-nvidia-gpu) == 0 ]]; then
        echo "Info: unset NVTEST_DRIVER_DIR for mesa driver"
        unset NVTEST_DRIVER_DIR
    fi
    
    DIRECT_CALL=1
    if [[ $DIRECT_CALL == 1 ]]; then
        check-display
    fi
    
    FPS_FILE=""
    for i in `seq 1 $ROUNDS`; do
        if [[ $VERBOSE == 1 ]]; then
            if [[ $DIRECT_CALL == 0 ]]; then
                /mnt/linuxqa/nvt.sh DxvkApexLegends --traces Apex_Legends_Ultra_3840x2160_1xAA_16xAF
            else
                . $(dirname $0)/apex_legends_lnxstress_120
            fi
        else
            if [[ $DIRECT_CALL == 0 ]]; then
                /mnt/linuxqa/nvt.sh DxvkApexLegends --traces Apex_Legends_Ultra_3840x2160_1xAA_16xAF \
                1> $HOME/Apex_Legends_Ultra_3840x2160_1xAA_16xAF.log \
                2> $HOME/Apex_Legends_Ultra_3840x2160_1xAA_16xAF.error && (
                    cat $HOME/Apex_Legends_Ultra_3840x2160_1xAA_16xAF.log | grep -o 'dxvk-v[0-9.]*-fps[[:blank:]]\+[0-9.]*' | awk '{print $2}' | tee -a $HOME/Apex_Legends_Ultra_3840x2160_1xAA_16xAF.$ROUNDS.fps
                    FPS_FILE=$HOME/Apex_Legends_Ultra_3840x2160_1xAA_16xAF.$ROUNDS.fps
                ) || (
                    cat $HOME/Apex_Legends_Ultra_3840x2160_1xAA_16xAF.log
                    cat $HOME/Apex_Legends_Ultra_3840x2160_1xAA_16xAF.error
                )
            else
                source /root/bin/apex_legends_lnxstress_120 1> $HOME/Apex_Legends.log 2> $HOME/Apex_Legends.error && (
                    cat $HOME/Apex_Legends.log | grep -o 'average FPS: [0-9.]*' | awk '{print $3}' | tee -a $HOME/Apex_Legends.$ROUNDS.fps
                    FPS_FILE=$HOME/Apex_Legends.$ROUNDS.fps
                ) || (
                    cat $HOME/Apex_Legends.log
                    cat $HOME/Apex_Legends.error
                )
            fi
        fi
    done
    
    if [[ $ROUNDS > 1 && -f $FPS_FILE ]]; then
        average $FPS_FILE
    fi
}
    
function catia() {
    if [[ $EUID != 0 ]]; then
        echo "Error: please run as root" > /dev/stderr
        exit 1
    fi
    
    check-display
    
    pushd /root/nvt/tests/viewperf2020v3/viewperf2020 > /dev/null
    
    if [[ $1 == -v ]]; then
        viewperf/bin/viewperf viewsets/catia/config/catia.xml -resolution 3840x2160
    else
        viewperf/bin/viewperf viewsets/catia/config/catia.xml -resolution 3840x2160 \
        1> $HOME/catia_3840x2160.log \
        2> $HOME/catia_3840x2160.error && (
            cat $HOME/catia_3840x2160.log | grep "<Composite Score=" | grep -o '".*"' | awk '{print substr($0, 2, length($0) - 2)}'
        ) || (
            cat $HOME/catia_3840x2160.log
            cat $HOME/catia_3840x2160.error
        )
    fi
    
    popd > /dev/null
}

function prime-run() {
    export __NV_PRIME_RENDER_OFFLOAD=1
    export __GLX_VENDOR_LIBRARY_NAME=nvidia
    export __VK_LAYER_NV_optimus=NVIDIA_only
    export VK_ICD_FILENAMES=/usr/share/vulkan/icd.d/nvidia_icd.json
    if [[ ! -f $VK_ICD_FILENAMES ]]; then 
        export VK_ICD_FILENAMES=/etc/vulkan/icd.d/nvidia_icd.json
    fi
    exec "$@"
}

function cpu-count() {
    lscpu | grep "^CPU(s):" | awk '{print $2}'
}

function cpu-offline() {
    if [[ -z $1 ]]; then
        echo "Error: No CPU to put offline" > /dev/stderr
        exit 1
    fi
    
    for RANGE in $@; do
        for i in `seq $(parse-range $RANGE)`; do
            echo 0 | sudo tee /sys/devices/system/cpu/cpu$i/online > /dev/null
        done
    done
}

function cpu-online() {
    for i in `seq 1 $(($(cpu-count) - 1))`; do
        echo 1 | sudo tee /sys/devices/system/cpu/cpu$i/online > /dev/null
    done
}

function pull-transient() {
    if [[ ! -d /tmp/zhujie ]]; then 
        git clone https://github.com/wanlizhu/zhujie /tmp/zhujie
    fi 
    
    cd /tmp/zhujie
    git pull
    cp -f /tmp/zhujie/zhujie $0
}

function pull() {
    GIT_REPO=$(dirname $0)
    if [[ ! -d $GIT_REPO/.git ]]; then
        pull-transient
        return
    fi
    
    pushd $GIT_REPO > /dev/null
    git pull https://github.com/wanlizhu/zhujie master
    popd > /dev/null 
}

function push() {
    GIT_REPO=$(dirname $0)
    if [[ ! -d $GIT_REPO/.git ]]; then
        echo "Error: '$GIT_REPO' is not a Git repository" > /dev/stderr
        exit 1
    fi
    
    echo "Info: push git repo from $GIT_REPO"
    pushd "$GIT_REPO" > /dev/null
    git add .
    git commit -m "$(date)"
    git push --set-upstream https://github.com/wanlizhu/zhujie master
    popd > /dev/null
}

function vpn() {
    if [[ $1 == off ]]; then
        sudo pkill -9 `pidof openconnect` 
        return
    fi
    
    if [[ -z $1 ]]; then
        read -p "DUO pass code: " CODE
    else
        CODE=$1
    fi
    
    which openconnect || (
        echo "Error: can't find openconnect in PATH" > /dev/stderr
        exit 1
    )
    
    echo "Xavier#35224047,$CODE" | sudo openconnect --authgroup Employee -u wanliz https://ngvpn32.vpn.nvidia.com:8443
}

function mean() {
    FILE=$1
    if [[ ! -f $FILE ]]; then
        echo "Error: '$FILE' doesn't exist" > /dev/stderr
        exit 1
    fi
    
    python3 -c "
import statistics as stat
columns = []
labels = []
with open(\"$FILE\", \"r\") as file:
    for line in [ line.strip() for line in file.readlines() ]:
        NW = -1
        for word in [ word.strip() for word in line.split(',') ]:
            NW += 1
            if len(columns) == 0:
                columns = [ [] for x in line.split(',') ]
                labels = [ 'FPS' for x in columns ]
            if word.replace('.', '0').replace('-', '0').isdigit():
                columns[NW].append(float(word))
            else:
                labels[NW] = word
for i in range(0, len(columns)):
    print('{}: {:.4f}'.format(labels[i], stat.mean(columns[i])))
"
}

function mean2() {
    FILE=$1
    if [[ ! -f $FILE ]]; then
        echo "Error: '$FILE' doesn't exist" > /dev/stderr
        exit 1
    fi
    
    python3 -c "
import statistics as stat
columns = []
labels = []
with open(\"$FILE\", \"r\") as file:
    for line in [ line.strip() for line in file.readlines() ]:
        NW = -1
        for word in [ word.strip() for word in line.split(',') ]:
            NW += 1
            if len(columns) == 0:
                columns = [ [] for x in line.split(',') ]
                labels = [ 'FPS' for x in columns ]
            if word.replace('.', '0').replace('-', '0').isdigit():
                columns[NW].append(float(word))
            else:
                labels[NW] = word
for i in range(0, len(columns)):
    print('{}: {:.4f} (StdDev: {:.4f})'.format(labels[i], stat.mean(columns[i]), stat.stdev(columns[i])))
"
}

function average() {
    mean2 "$@"
}

function loop() {
    if [[ -z $1 ]]; then
        echo "Usage: loop <TIMES> <CMD>" > /dev/stderr
        exit 1
    fi
        
    rm -rf $HOME/zhujie-loop.records
    for i in `seq 1 $1`; do
        $2 | tee -a $HOME/zhujie-loop.records
    done
        
    if [[ -f "$HOME/zhujie-loop.records" ]]; then
        echo ""
        average $HOME/zhujie-loop.records
    fi
}

function loop-v() {
    if [[ -z $1 ]]; then
        echo "Usage: loop <TIMES> <CMD>" > /dev/stderr
        exit 1
    fi
        
    rm -rf $HOME/zhujie-loop.records
    for i in `seq 1 $1`; do
        $2 | tee -a $HOME/zhujie-loop.records
    done
        
    if [[ -f "$HOME/zhujie-loop.records" ]]; then
        echo ""
        average $HOME/zhujie-loop.records
        visualize $HOME/zhujie-loop.records
    fi
}

function parse-range() {
    if [[ $1 == *"-"* ]]; then
        echo "${1/-/ }"
    else
        echo "$1 $1"
    fi
}

function visualize() {
    INFILE=""
    TITLE=""
    XLABEL=""
    YLABEL=""
    
    while [[ -n $1 ]]; do
        case $1 in
             -i|--input) shift; INFILE=$1 ;;
             -t|--title) shift; TITLE=$1 ;;
            -x|--xlabel) shift; XLABEL=$1 ;;
            -y|--ylabel) shift; YLABEL=$1 ;;
            *)
                if [[ -f $1 ]]; then
                    INFILE=$1
                fi
            ;;
        esac
        shift
    done
    
    if [[ ! -f $INFILE ]]; then
        echo "Usage: visualize -i <INFILE> -t <TITLE> -x <XLABEL> -y <YLABEL>" > /dev/stderr
        exit 1
    fi
    
    if [[ -z $TITLE ]]; then
        TITLE=$(basename $INFILE)
    fi
    
    if [[ -z $XLABEL ]]; then
        XLABEL="Test Index"
    fi
    
    if [[ -z $YLABEL ]]; then
        YLABEL="Average FPS"
    fi
    
    python3 -c "
from signal import signal, SIGINT
from sys import exit
import subprocess as subproc
try:
    import matplotlib
    import numpy
except ImportError:
    subproc.run('python3 -m pip install matplotlib', shell=True, check=True)
    subproc.run('python3 -m pip install numpy', shell=True, check=True)
import matplotlib
import matplotlib.pyplot as plt
import numpy as np
import statistics as stat

def sigint_proc(signal_received, frame):
    print('SIGINT or CTRL-C detected')
    exit(0)

signal(SIGINT, sigint_proc)

def viz_polyline(values):
    values=np.array(values)
    pos=np.array(list(range(1, len(values)+1)))
    ymax=values.max()
    ymin=values.min()
    xmax=pos[np.argmax(values)]
    xmin=pos[np.argmin(values)]
    delta=(values.max() - values.min()) / 15.0
    plt.suptitle(\"$TITLE\")
    plt.title('Mean: {}, StdDev: {:.4f}'.format(stat.mean(values), stat.stdev(values), fontweight='bold'), fontweight='bold')
    plt.xlabel(\"$XLABEL\", fontweight='bold')
    plt.ylabel(\"$YLABEL\", fontweight='bold')
    plt.xticks(np.arange(pos.min(), pos.max(), 1))
    plt.yticks(np.arange(values.min(), values.max(), delta))
    plt.plot(pos, values, color='blue')
    plt.annotate('Max: {}'.format(ymax), xy=(xmax, ymax), xytext=(xmax, ymax))
    plt.annotate('Min: {}'.format(ymin), xy=(xmin, ymin), xytext=(xmin, ymin))
    plt.savefig(\"$INFILE.png\")
    plt.show()

def viz_polylines(values_list):
    if len(values_list) == 1:
        viz_polyline(values_list[0])
    else:
        for V in values_list:
            print(V)
    
values_list = []
with open(\"$INFILE\") as file:
    lines = file.readlines()
    for j in range(0, len(lines)):
        words = lines[j].strip().split(',')
        if not values_list:
            values_list = [[] for x in words]
            try:
                _ = float(words[0])
            except:
                continue
        for i in range(0, len(words)):
            values_list[i].append(float(words[i]))
            
viz_polylines(values_list)
"
}

function randoms() {
    if [[ -z $1 ]]; then
        echo "Usage: randoms <COUNT> <MIN> <MAX>" > /dev/stderr
        exit 1
    fi
    
    COUNT=$1
    MIN=$([[ -z $2 ]] && echo 0 || echo $2)
    MAX=$([[ -z $3 ]] && echo 100 || echo $3)
    NUMBERS=""
    
    for i in `seq 1 $COUNT`; do
        NUM=$(($MIN + $RANDOM % $MAX))
        if [[ -z $NUMBERS ]]; then
            NUMBERS=$NUM
        else
            NUMBERS="$NUMBERS $NUM"
        fi
    done
    
    echo $NUMBERS
}

function image() {
    if [[ -z $1 ]]; then
        echo "Usage: image <SUBCMD> [FILE...]" > /dev/stderr
        exit 1
    fi

    case $1 in
        combine)
            shift
            combine-images "$@"
        ;;
    esac
}

function combine-images() {
    FILES=""
    VERTICAL=0

    while [[ -n $1 ]]; do
        case $1 in
              -v|--vertical) VERTICAL=1 ;;
            -h|--horizontal) VERTICAL=0 ;;
            *)
                if [[ -z $FILES ]]; then
                    FILES="\"$1\""
                else
                    FILES="$FILES, \"$1\""
                fi
            ;;
        esac
        shift
    done

    python3 -c "
import sys
import subprocess as subproc
try:
    from PIL import Image
except:
    subproc.run('python3 -m pip install PIL', shell=True, check=True)
from PIL import Image

images = [Image.open(x) for x in [$FILES]]
widths, heights = zip(*(img.size for img in images))

if \"$VERTICAL\" == \"1\":
    sum_height = sum(heights)
    max_width = max(widths)
    new_image = Image.new('RGB', (max_width, sum_height))
    
    y_offset = 0
    for image in images:
        new_image.paste(image, (0, y_offset))
        y_offset += image.size[1]
else:
    sum_width = sum(widths)
    max_height = max(heights)
    new_image = Image.new('RGB', (sum_width, max_height))
    
    x_offset = 0
    for image in images:
        new_image.paste(image, (x_offset, 0))
        x_offset += image.size[0]

new_image.save('combined-image.jpg')
"
}

function check-ssh() {
    if [[ -z $1 ]]; then
        echo "Usage: check-ssh <IP>" > /dev/stderr
        exit 1
    fi
    
    which nmap > /dev/null || sudo apt install -y nmap
    nmap $1 -Pn -p ssh | egrep -io 'open|closed|filtered'
}

function find-mac-ip() {
    if [[ -f $HOME/.zhujie/mac-ip ]]; then
        MAC_IP=$(cat $HOME/.zhujie/mac-ip)
        if [[ $(check-ssh $MAC_IP) == open ]]; then
            echo $MAC_IP && return
        else
            echo "Info: SSH server ($MAC_IP:22) is not available"
        fi
    fi
}

function ip() {
     ifconfig | grep "inet " | awk '{print $2}' | sort
}

function z() {
    zhujie "$@"
}








case $1 in
    help)
        echo "Usage: zhujie <SUBCMD>" > /dev/stderr
        exit 1
    ;;
    ip)
        shift
        ip "$@"
    ;;
    pull)
        shift
        pull "$@"
    ;;
    push)
        shift
        push "$@"
    ;;
    build)
        shift
        build "$@"
    ;;
    install)
        shift
        install "$@"  
    ;;
    rm|remove)
        shift
        remove "$@"
    ;;
    ddnet)
        shift
        ddnet "$@"
    ;;
    talos)
        shift
        talos "$@"
    ;;
    drv|drivers)
        shift
        drivers "$@"
    ;;
    flgf|flamegraph)
        shift
        flamegraph "$@"
    ;;
    info)
        shift
        info "$@"
    ;;
    p4bisect)
        shift
        p4bisect "$@"
    ;;
    pic-v)
        shift
        pic-v "$@"
    ;;
    vpn)
        shift
        vpn "$@"
    ;;
    prime-run)
        shift
        prime-run "$@"
    ;;
    cskn|choose-kernel)
        shift
        choose-kernel "$@"
    ;;
    mean)
        shift
        mean "$@"
    ;;
    mean2)
        shift
        mean2 "$@"
    ;;
    average)
        shift
        average "$@"
    ;;
    fkdp|fake-display)
        shift
        fake-display "$@"
    ;;
    vnc)
        shift
        vnc "$@"
    ;;
    apex)
        shift
        apex "$@"
    ;;
    catia)
        shift
        catia "$@"
    ;;
    dp|display)
        shift
        display "$@"
    ;;
    loop)
        shift
        loop "$@"
    ;;
    loop-v)
        shift
        loop-v "$@"
    ;;
    cpu-offline)
        shift
        cpu-offline "$@"
    ;;
    cpu-online)
        shift
        cpu-online "$@"
    ;;
    cpu)
        shift
        cpu "$@"
    ;;
    gpu)
        shift
        gpu "$@"
    ;;
    viz|visualize)
        shift
        visualize "$@"
    ;;
    img|image)
        shift
        image "$@"
    ;;
    mac)
        shift
        while [[ -z $(find-mac-ip) ]]; do
            read -p "Mac's IP: " MAC_IP
            mkdir -p $HOME/.zhujie
            echo $MAC_IP > $HOME/.zhujie/mac-ip
        done
        scp "$@" zhujie@$(find-mac-ip):~/Downloads/
    ;;
    test)
        for i in `seq 1 20`; do
            cpu-online
            cpu-offline $(randoms 8 1 23)
            talos >> talos-disable-random-8-cores.log
        done
        cpu-online 
    ;;
esac
